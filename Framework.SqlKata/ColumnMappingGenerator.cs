using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

// 标记为 Source Generator
[Generator]
public class ColumnMappingGenerator : IIncrementalGenerator
{
    // 假设您的 ColumnAttribute 位于这些命名空间
    private const string ColumnAttributeName = "System.ComponentModel.DataAnnotations.Schema.ColumnAttribute";
    private const string NotMappedAttributeName = "System.ComponentModel.DataAnnotations.Schema.NotMappedAttribute";
    private const string SqlKataColumnAttributeName = "SqlKata.ColumnAttribute";
    private const string IgnoreAttributeName = "IgnoreAttribute"; // 假设您自定义的 IgnoreAttribute

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 步骤 1: 筛选出所有标记了 ColumnAttribute 的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                // 谓词: 查找所有具有特性列表的类
                predicate: static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 } c,
                // 转换器: 获取类的语义模型
                transform: static (ctx, _) => GetClassWithRelevantAttributes(ctx.Node as ClassDeclarationSyntax, ctx.SemanticModel)
            )
            .Where(static c => c is not null);

        // 步骤 2: 将筛选出的类分组并生成代码
        context.RegisterSourceOutput(classDeclarations,
            static (spc, source) => Execute(spc, source));
    }

    // 辅助方法：检查类是否包含任何我们关注的特性（或简单地检查所有公共类）
    private static ClassDeclarationSyntax GetClassWithRelevantAttributes(ClassDeclarationSyntax classDeclaration, SemanticModel semanticModel)
    {
        // 简化的逻辑：为了生成所有类的映射，我们只需要确保它是公共非静态类
        if (classDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword) &&
            !classDeclaration.Modifiers.Any(SyntaxKind.StaticKeyword))
        {
            return classDeclaration;
        }
        return null;
    }

    // 执行生成代码的逻辑
    private static void Execute(SourceProductionContext context, ClassDeclarationSyntax classDeclaration)
    {
        if (classDeclaration == null) return;

        var semanticModel = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

        if (classSymbol == null || classSymbol.TypeKind != TypeKind.Class) return;

        // 确保类是公共的
        if (classSymbol.DeclaredAccessibility != Accessibility.Public) return;

        // 获取命名空间和类名
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        // 生成代码
        var code = GenerateMapClass(classSymbol, namespaceName, className);

        // 添加到编译
        context.AddSource($"{className}Map.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    // 核心逻辑：遍历属性并生成 C# 代码字符串
    private static string GenerateMapClass(INamedTypeSymbol classSymbol, string namespaceName, string className)
    {
        var sb = new StringBuilder();

        // 导入必要的命名空间
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        // 遵循约定：类名为 [ModelName]Map
        sb.AppendLine($"    internal static class {className}Map");
        sb.AppendLine("    {");

        // ----------------------------------------------------
        // 生成 Columns 字典 (替换 GetColumns<T>() 的逻辑)
        // ----------------------------------------------------
        sb.AppendLine($"        public static readonly IReadOnlyDictionary<string, string> Columns = ");
        sb.AppendLine($"            new Dictionary<string, string>(StringComparer.Ordinal)");
        sb.AppendLine("            {");

        // 查找所有公共实例属性
        var properties = classSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToList();

        foreach (var prop in properties)
        {
            var propertyName = prop.Name;
            string columnName = null;
            bool isNotMapped = false;

            // 检查 NotMapped 或 Ignore 特性
            if (prop.GetAttributes().Any(attr =>
                attr.AttributeClass.ToDisplayString() == NotMappedAttributeName ||
                attr.AttributeClass.ToDisplayString() == IgnoreAttributeName))
            {
                isNotMapped = true;
            }

            if (isNotMapped)
            {
                continue; // 跳过被忽略的属性
            }

            // 查找 Column 特性
            var columnAttribute = prop.GetAttributes().FirstOrDefault(attr =>
                attr.AttributeClass.ToDisplayString() == ColumnAttributeName ||
                attr.AttributeClass.ToDisplayString() == SqlKataColumnAttributeName);

            if (columnAttribute != null && columnAttribute.ConstructorArguments.Length > 0)
            {
                // 假设特性构造函数是 [Column("column_name")]
                columnName = columnAttribute.ConstructorArguments[0].Value?.ToString();
            }

            // 如果没有特性，默认使用属性名
            columnName ??= propertyName;

            sb.AppendLine($"                {{ \"{propertyName}\", \"{columnName}\" }},");
        }

        sb.AppendLine("            };");

        // ----------------------------------------------------
        // 生成 GetColumnName 方法 (替换 GetMemberName 中的反射逻辑)
        // ----------------------------------------------------
        sb.AppendLine();
        sb.AppendLine("        // Replaces single GetCustomAttribute<ColumnAttribute>() lookups");
        sb.AppendLine("        public static string GetColumnName(string propertyName)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (Columns.TryGetValue(propertyName, out var columnName))");
        sb.AppendLine("            {");
        sb.AppendLine("                return columnName;");
        sb.AppendLine("            }");
        sb.AppendLine("            // If not found (e.g., nested property access), return the original name for FormatNestedMemberName to handle.");
        sb.AppendLine("            return propertyName;");
        sb.AppendLine("        }");

        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
}