using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable RS1035 // Do not use banned APIs for analyzers

namespace SqlKata.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class SourceGenerators : IIncrementalGenerator
{
    private const string TableAttribute = "System.ComponentModel.DataAnnotations.Schema.TableAttribute";
    // 假设您的 ColumnAttribute 位于这些命名空间
    private const string ColumnAttributeName = "System.ComponentModel.DataAnnotations.Schema.ColumnAttribute";
    private const string NotMappedAttributeName = "System.ComponentModel.DataAnnotations.Schema.NotMappedAttribute";
    private const string SqlKataColumnAttributeName = "SqlKata.ColumnAttribute";
    private const string IgnoreAttributeName = "IgnoreAttribute"; // 假设您自定义的 IgnoreAttribute

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        Debugger.Launch();
        // 步骤 A: 筛选出 INamedTypeSymbol (就像您之前做的)
        var classSymbolsProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                // 谓词: 查找所有类声明
                predicate: static (s, _) => s is ClassDeclarationSyntax c,
                // 转换器: 将语法节点和语义模型打包
                transform: static (ctx, ct) =>
                {
                    var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, cancellationToken: ct) as INamedTypeSymbol;
                    if (symbol != null &&
                        symbol.TypeKind == TypeKind.Class &&
                        symbol.DeclaredAccessibility == Accessibility.Public)
                    {
                        // 语义过滤：检查该类是否包含 System.ComponentModel.DataAnnotations.Schema.TableAttribute
                        if (symbol.GetAttributes().Any(attr =>
                            attr.AttributeClass?.ToDisplayString() == TableAttribute))
                        {
                            return symbol;
                        }
                    }
                    return null;
                })
            .Where(static s => s is not null);


        // 步骤 B: 将 Symbols 与 CompilationProvider 结合
        var compilationAndSymbols = context.CompilationProvider
            .Combine(classSymbolsProvider.Collect()); // Collect() 将所有符号收集到一个不可变数组 ImmutableArray 中

        // 步骤 C: 注册 Source Output
        context.RegisterSourceOutput(compilationAndSymbols,
            static (spc, source) =>
            {
                // source 现在是 (Compilation, ImmutableArray<INamedTypeSymbol>)
                var compilation = source.Left;
                var symbols = source.Right;

                foreach (var classSymbol in symbols)
                {
                    // 现在您拥有了 classSymbol (元数据) 和 compilation
                    // ... 调用您的 Execute 逻辑
                    Execute(spc, classSymbol);
                }
            });
    }

    // 执行生成代码的逻辑
    private static void Execute(SourceProductionContext context, INamedTypeSymbol classSymbol)
    {
        // 原始代码中的所有语义查找和检查已经被 IIncrementalGenerator 管道处理。

        // 获取命名空间和类名
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        // 生成代码
        var code = GenerateMapClass(classSymbol, namespaceName, className);

        // 添加到编译
        context.AddSource($"{className}Map.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    // 核心逻辑：遍历属性并生成 C# 代码字符串
    private static string GenerateMapClass(INamedTypeSymbol classSymbol, string namespaceName, string className)
    {
        var sb = new StringBuilder();

        // 导入必要的命名空间
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System;");
        sb.AppendLine("using Framework.SqlKata;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        // 遵循约定：类名为 [ModelName]Map
        sb.AppendLine($"    public partial class {className}");
        sb.AppendLine("    {");

        // ----------------------------------------------------
        // 生成 Columns 字典 (替换 GetColumns<T>() 的逻辑)
        // ----------------------------------------------------
        sb.AppendLine($"        static {className}()");
        sb.AppendLine("         {");
        sb.AppendLine($"               FluentQuery.AddColumns(typeof({namespaceName}.{className}), new Dictionary<string, string>(StringComparer.Ordinal)");
        sb.AppendLine("                {");

        // 查找所有公共实例属性
        var properties = classSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToList();

        foreach (var prop in properties)
        {
            var propertyName = prop.Name;
            string columnName = null;
            bool isNotMapped = false;

            // 检查 NotMapped 或 Ignore 特性
            if (prop.GetAttributes().Any(attr =>
                attr.AttributeClass.ToDisplayString() == NotMappedAttributeName ||
                attr.AttributeClass.ToDisplayString() == IgnoreAttributeName))
            {
                isNotMapped = true;
            }

            if (isNotMapped)
            {
                continue; // 跳过被忽略的属性
            }

            // 查找 Column 特性
            var columnAttribute = prop.GetAttributes().FirstOrDefault(attr =>
                attr.AttributeClass.ToDisplayString() == ColumnAttributeName ||
                attr.AttributeClass.ToDisplayString() == SqlKataColumnAttributeName);

            if (columnAttribute != null && columnAttribute.ConstructorArguments.Length > 0)
            {
                // 假设特性构造函数是 [Column("column_name")]
                columnName = columnAttribute.ConstructorArguments[0].Value?.ToString();
            }

            // 如果没有特性，默认使用属性名
            columnName ??= propertyName;

            sb.AppendLine($"                        {{ \"{propertyName}\", \"{columnName}\" }},");
        }

        sb.AppendLine("            });");
        sb.AppendLine("    }");
        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
}